
<!DOCTYPE html>
<html>
  <head>
    <title>3D Icosahedron</title>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script src="https://threejs.org/build/three.js"></script> 
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <script>
      const renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const fov = 75;
      const aspect = window.innerWidth / window.innerHeight;
      const near = 0.01;
      const far = 50;
      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      let bombPlacements = [];
      camera.position.z = 5;

      const scene = new THREE.Scene();

      const caster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      const detail = 3;
      let revealedTriangles = 0;

      const icosahedron = makeIcosahedron(new THREE.IcosahedronGeometry(3, detail), new THREE.MeshPhongMaterial({
        color: 0xadd8e6,
        shininess: 10, // Was 100
        vertexColors: true
        // specular: 0x000000,
        // flatShading: true,
      }));
      icosahedron.geometry.computeVertexNormals();

      function computeAdjacentFaceIndicesMap(positionArray) {
        result = {};
        for (let i = 0; i < positionArray.length; i += 3) {
          const slice = positionArray.slice(i, i + 3);
          const key = slice[0].toString() + '|' + slice[1].toString() + '|' + slice[2].toString();
          if (result[key] !== undefined) {
            result[key].push(Math.floor(i / 9));
          } else {
            result[key] = [Math.floor(i / 9)];
          }
        }
        return result;
      }

      const adjacentFaceIndicesMap = computeAdjacentFaceIndicesMap(icosahedron.geometry.attributes.position.array);

      const wireframeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true, transparent: true, shading: THREE.FlatShading, vertexColors: true } );
      const newGeometry = new THREE.IcosahedronGeometry(3.001, detail);
      const totalFaces = newGeometry.attributes.position.count / 3;
      const bombs = Math.floor(totalFaces / 4.4);
      const wireframe = new THREE.Mesh(newGeometry, wireframeMaterial);
      icosahedron.add(wireframe);

      const light = new THREE.DirectionalLight(0xffffff, 0.8);
      light.position.set(0, 0, 1);
      scene.add(light);
      const lightTop = new THREE.DirectionalLight(0xffffff, 0.8);
      lightTop.position.set(1, 3, 0.5);
      scene.add(lightTop);

      const lightBottom = new THREE.DirectionalLight(0xffffff, 1);
      // light.position.set(1, 2, 3);
      lightBottom.position.set(-1, -3, -0.5);
      scene.add(lightBottom);

      let isDragging = false;
      let mouseDown = false;
      let mouseMoves = 0;

      let clickedIntersection = null; // debugging
      function getKey(x, y, z) {
        return x.toString() + '|' + y.toString() + '|' + z.toString();
      }

      function getSurroundingBombsTotal(vA, vB, vC) {
        let adjacentIndices = [];
        // const key1 = vA.x.toString() + '|' + vA.y.toString() + '|' + vA.z.toString()
        // const val1 = adjacentFaceIndicesMap[vA.x.toString() + '|' + vA.y.toString() + '|' + vA.z.toString()];
        // console.log(val1);
        adjacentIndices = adjacentIndices.concat(adjacentFaceIndicesMap[getKey(vA.x, vA.y, vA.z)]);
        adjacentIndices = adjacentIndices.concat(adjacentFaceIndicesMap[getKey(vB.x, vB.y, vB.z)]);
        adjacentIndices = adjacentIndices.concat(adjacentFaceIndicesMap[getKey(vC.x, vC.y, vC.z)]);
        const uniqueAdjacentIndices = Array.from(new Set(adjacentIndices));
        return uniqueAdjacentIndices.map(ind => bombPlacements[ind]).filter(val => !!val).length;
      }

      const bombColorMap = {
        0: new THREE.Color(0x5A5A5A),
        1: new THREE.Color(0x000055),
        2: new THREE.Color(0x00ff00),
        3: new THREE.Color(0xff0000),
        4: new THREE.Color(0xA020F0),
        5: new THREE.Color(0x964B00),
        6: new THREE.Color(0x0D98BA),
        7: new THREE.Color(0x5A5A5A),
        8: new THREE.Color(0xD3D3D3),
        9: new THREE.Color(0xFFC0CB),
        10: new THREE.Color(0x00FFFF),
        11: new THREE.Color(0xFFFF00),
        12: new THREE.Color(0xFF00FF),
      }

      function onClick(event) {
        mouseDown = false;
        if (isDragging && mouseMoves > 5) {
          isDragging = false;
          mouseMoves = 0;
          return false;
        };
        mouseMoves = 0;
        event.preventDefault();

        mouse.x = (event.clientX / renderer.domElement.offsetWidth) * 2 - 1;
        mouse.y = -(event.clientY / renderer.domElement.offsetHeight) * 2 + 1;

        caster.setFromCamera(mouse, camera);

        const intersects = caster.intersectObjects(scene.children);

        if (intersects.length > 0) {

          const intersection = intersects[1];
          clickedIntersection = intersection; // Debugging

          const colorAttribute = intersection.object.geometry.getAttribute('color');
          const face = intersection.face;
          var vA = new THREE.Vector3();
          var vB = new THREE.Vector3();
          var vC = new THREE.Vector3();
          var geometry = intersection.object.geometry;
          var position = geometry.attributes.position;
          vA.fromBufferAttribute(position, face.a);
          vB.fromBufferAttribute(position, face.b);
          vC.fromBufferAttribute(position, face.c);
          const vAkey = vA.x.toString() + '|' + vA.y.toString() + '|' + vA.z.toString();
          const vBkey = vB.x.toString() + '|' + vB.y.toString() + '|' + vB.z.toString();
          const vCkey = vC.x.toString() + '|' + vC.y.toString() + '|' + vC.z.toString();

          const isBomb = bombPlacements[intersection.faceIndex];
          let color = new THREE.Color(0xFFFFFF);
          if (isBomb) {
            color = new THREE.Color(0x000000); // Game over
            console.log('Game over')
          } else {
            const surroundingBombs = getSurroundingBombsTotal(vA, vB, vC);
            console.log(surroundingBombs);
            color = bombColorMap[surroundingBombs];
            revealedTriangles++;
            if (revealedTriangles === totalFaces - bombs) console.log('You win!');
          }

          colorAttribute.setXYZ(face.a, color.r, color.g, color.b);
          colorAttribute.setXYZ(face.b, color.r, color.g, color.b);
          colorAttribute.setXYZ(face.c, color.r, color.g, color.b);

          colorAttribute.needsUpdate = true;
        }
        return false;
      }

      function getBombPlacements(totalFaces, totalBombs) {
        const bombPlacements = Array(totalFaces).fill(0); // create an array of totalFaces elements, filled with 0s
        let bombsPlaced = 0;

        while (bombsPlaced < totalBombs) {
          const index = Math.floor(Math.random() * totalFaces); // generate a random index
          if (bombPlacements[index] === 0) { // if the element at the index is 0, replace it with 1
            bombPlacements[index] = 1;
            bombsPlaced++;
          }
        }
        return bombPlacements;
      }

      function makeIcosahedron(geometry, materials, x = 0, y = 0) {
        // const icosahedron = new THREE.Mesh(geometry, Array(180).fill(materials));
        const icosahedron = new THREE.Mesh(geometry, materials);

        const positionAttribute = geometry.getAttribute('position');
        const colors = [];

        for (let i = 0; i < positionAttribute.count; i++) {
          colors.push(1, 1, 1); // add for each vertex color data
        }

        const totalFaces = geometry.attributes.position.count / 3;
        const totalBombs = Math.floor(totalFaces / 4.84);
        bombPlacements = getBombPlacements(totalFaces, totalBombs);
        const colorAttribute = new THREE.Float32BufferAttribute(colors, 3);
        geometry.setAttribute('color', colorAttribute);

        icosahedron.position.x = x;
        icosahedron.position.y = y;

        scene.add(icosahedron);

        return icosahedron;
      }

      function render() {

        requestAnimationFrame(render);

        renderer.render(scene, camera);

      }

      window.addEventListener("click", onClick, false);

      function onRightClick(event) {
        mouse.x = (event.clientX / renderer.domElement.offsetWidth) * 2 - 1;
        mouse.y = -(event.clientY / renderer.domElement.offsetHeight) * 2 + 1;

        caster.setFromCamera(mouse, camera);

        const intersects = caster.intersectObjects(scene.children);

        if (intersects.length > 0) {

          const intersection = intersects[1];
          clickedIntersection = intersection; // Debugging

          const colorAttribute = intersection.object.geometry.getAttribute('color');
          const face = intersection.face;
          var vA = new THREE.Vector3();
          var vB = new THREE.Vector3();
          var vC = new THREE.Vector3();
          var geometry = intersection.object.geometry;
          var position = geometry.attributes.position;
          vA.fromBufferAttribute(position, face.a);
          vB.fromBufferAttribute(position, face.b);
          vC.fromBufferAttribute(position, face.c);

          color = new THREE.Color(0x013220);

          colorAttribute.setXYZ(face.a, color.r, color.g, color.b);
          colorAttribute.setXYZ(face.b, color.r, color.g, color.b);
          colorAttribute.setXYZ(face.c, color.r, color.g, color.b);

          colorAttribute.needsUpdate = true;
        }
        return false;
      }
      window.oncontextmenu = onRightClick;

      document.addEventListener("mousedown", (event) => {
        mouseMoves = 0;
        mouseDown = true;
      });

      let previousMousePosition = {
        x: 0,
        y: 0,
      };
      document.addEventListener("mousemove", (event) => {
        if (mouseDown) {
          mouseMoves++;
          isDragging = true;
          const { x, y } = event;
          const deltaMove = {
            x: x - previousMousePosition.x,
            y: y - previousMousePosition.y,
          };

          const deltaRotationQuaternion = new THREE.Quaternion().setFromEuler(
            new THREE.Euler(
              (deltaMove.y * Math.PI) / 360,
              (deltaMove.x * Math.PI) / 360,
              0,
              "XYZ"
            )
          );

          icosahedron.quaternion.multiplyQuaternions(
            deltaRotationQuaternion,
            icosahedron.quaternion
          );
        }

        previousMousePosition = {
          x: event.x,
          y: event.y,
        };
      });
      render();
            
    </script>
  </body>
</html>

