<!DOCTYPE html>
<html>
  <head>
    <title>3D Icosahedron</title>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script src="https://threejs.org/build/three.js"></script> 
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: 'Roboto Mono', monospace;
      }
      canvas {
        width: 100%;
        height: 100%;
      }

  /* Style the radio button group container */
  .radio-group {
    position: fixed;
    top: 10px;
    left: 10px;
    z-index: 9999;
    display: inline-flex;
    flex-direction: column;
    background-color: #888;
    border: 1px solid #333;
    padding: 5px;
  }

  /* Style the individual radio buttons */
  .radio-group label {
    position: relative;
    display: inline-block;
    margin-bottom: 5px;
    color: #fff;
    cursor: pointer;
    user-select: none;
    font-size: 1.1rem;
  }

  /* Style the radio button input */
  .radio-group input {
    cursor: pointer;
  }

  /* Style the radio button indicator */
  .radio-group .checkmark {
    position: absolute;
    left: 0;
    top: 2px;
    height: 22px;
    width: 22px;
    background-color: #fff;
    border-radius: 50%;
    border: 1px solid #333;
  }

  /* Style the checked radio button indicator */
  .radio-group input:checked + .checkmark::after {
    content: '';
    position: absolute;
    display: block;
    top: 5px;
    left: 5px;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background-color: #333;
  }
    </style>
  </head>
  <body>
    <div class="radio-group">
      <label>
        <input type="radio" name="difficulty" value="1" checked>
        <span>Beginner</span>
      </label>
      <label>
        <input type="radio" name="difficulty" value="2">
        <span>Intermediate</span>
      </label>
      <label>
        <input type="radio" name="difficulty" value="3">
        <span>Expert</span>
      </label>
    </div>
    <script>
      // Get the radio buttons
      const radioButtons = document.querySelectorAll('.radio-group input');

      // Add event listeners to the radio buttons
      radioButtons.forEach(function(radioButton) {
        radioButton.addEventListener('click', function() {
          const difficulty = Number(this.value);
          startGame(difficulty);
        });
      });

      window.onClickHandler = () => {};
      window.onRightClickHandler = () => {};
      window.onRightClickHandler = () => {};
      window.onMouseDown = () => {};
      window.onMouseMoveHandler = () => {};
      document.addEventListener("mousedown", (event) => window.onMouseDown(event));
      window.oncontextmenu = (event) => window.onRightClickHandler(event);
      window.addEventListener("click", (event) => window.onClickHandler(event), false);
      document.addEventListener("mousemove", (event) => window.onMouseMoveHandler(event));

      window.icosahedrons = [];
      let scene = new THREE.Scene();
      const startGame = function(detail=1) {
        console.log(window.icosahedrons.length - 1);
        let lastIcosahedron = window.icosahedrons[window.icosahedrons.length - 1];
        if (lastIcosahedron) {
          for(var i = scene.children.length - 1; i >= 0; i--) { 
               for(var j = scene.children[i].children.length - 1; j >= 0; j--) { 
                 const nestedChild = scene.children[i].children[j]
                 scene.children[i].remove(nestedChild);
               }
               obj = scene.children[i];
               scene.remove(obj); 
          }
          scene.remove.apply(scene, scene.children);
          icosahedrons.shift();
        }
        const BufferGeometry = THREE.BufferGeometry;
        const BufferAttribute = THREE.BufferAttribute;
        const Mesh = THREE.Mesh;
        const LineBasicMaterial = THREE.LineBasicMaterial;
        const Line = THREE.Line;
        let firstClickHappened = false;

        let gameOver = false;
        const indexGeometry = function(geometry) {
          const indexArray = [];
          const positionArray = geometry.attributes.position.array;
          for (let i = 0; i < positionArray.length / 3; i++) {
            indexArray.push(i);
          }
          geometry.setIndex(new THREE.BufferAttribute(new Uint16Array(indexArray), 1));
        }

        const vertexFaceNumberHelper = function ( camera, mesh, mode, size, color, faceIndex ) {
          // mode: 0 nothing, 1 vertex, 2 face, 3 vertex & face
          this.mode = mode;

          const positionCount = mesh.geometry.attributes.position.count;
          const faceCount = mesh.geometry.index.array.length / 3;

          const vertexNumbers = [];
          // if (!window.faceNumbers || !firstClickHappened) {
          if (!window.faceNumbers) {
            window.faceNumbers = [];
          }
          const materialDigits = new LineBasicMaterial( { color: color } );
          const geometryDigit = [];
          const digit = [];
          const digitPositions = [];
          let d100, d10, d1;      // digits

          const coordDigit = [];  // design of the digits
          coordDigit[ 0 ] = [ 0,0, 0,9, 6,9, 6,0, 0,0 ];
          coordDigit[ 1 ] = [ 0,6, 3,9, 3,0 ];
          coordDigit[ 2 ] = [ 0,9, 6,9, 6,6, 0,0, 6,0 ];
          coordDigit[ 3 ] = [ 0,9, 6,9, 6,5, 3,5, 6,5, 6,0, 0,0 ];
          coordDigit[ 4 ] = [ 0,9, 0,5, 6,5, 3,5, 3,6, 3,0 ];
          coordDigit[ 5 ] = [ 6,9, 0,9, 0,5, 6,5, 6,0, 0,0 ];
          coordDigit[ 6 ] = [ 6,9, 0,9, 0,0, 6,0, 6,5, 0,5 ];
          coordDigit[ 7 ] = [ 0,9, 6,9, 6,6, 0,0 ];
          coordDigit[ 8 ] = [ 0,0, 0,9, 6,9, 6,5, 0,5, 6,5, 6,0, 0,0 ];
          coordDigit[ 9 ] = [ 6,5, 0,5, 0,9, 6,9, 6,0, 0,0 ];

          for ( let i = 0; i < 10; i ++ ) {
              geometryDigit[ i ] = new BufferGeometry();
              digitPositions[ i ] =  new Float32Array( coordDigit[ i ].length / 2 * 3 );
              geometryDigit[ i ].setAttribute( 'position', new BufferAttribute( digitPositions[ i ], 3 ) );

              for ( let j = 0; j < coordDigit[ i ].length/ 2; j ++ ) {
                  digitPositions[ i ][ j * 3 ] =  0.1 * size * coordDigit[ i ][ 2 * j ];
                  digitPositions[ i ][ j * 3 + 1 ] = 0.1 * size * coordDigit[ i ][ 2 * j + 1 ];
                  digitPositions[ i ][ j * 3 + 2 ] = 0;
              }

              digit[ i ] = new Line( geometryDigit[ i ], materialDigits );
          }

          const posArray = mesh.geometry.attributes.position.array;
          const indArray = mesh.geometry.index.array;

          let x, y, z;

          let i100 =  0;
          let i10  =  0;
          let i1   = -1;

          function addBombAtFaceIndex(i) {
            // number on board, up to three digits are pinned there
            let board = null;
            if (!firstClickHappened) {
              board = new Mesh( new BufferGeometry( ) );
            } else {
              board = window.faceNumbers[i];
            }
            // const surroundingBombsKey = getKey(posArray[i*3], posArray[(i*3) + 1], posArray[(i*3) + 2]);
            var vA = new THREE.Vector3(posArray[i*9], posArray[(i*9) + 1], posArray[(i*9) + 2]);
            var vB = new THREE.Vector3(posArray[(i*9) + 3], posArray[(i*9) + 4], posArray[(i*9) + 5]);
            var vC = new THREE.Vector3(posArray[(i*9) + 6], posArray[(i*9) + 7], posArray[(i*9) + 8]);
          
            const surroundingBombs = getSurroundingBombsTotal(vA, vB, vC);
            const isBomb = bombPlacements[i];
            if (!isBomb && i === faceIndex) {
              // return;
              numbering(board, surroundingBombs); // numbering the faces, hundreds ...
            }
            // numbering(board, surroundingBombs); // numbering the faces, hundreds ...
            // window.faceNumbers.push( board );  // place the table in the face numbering data field
            window.faceNumbers[i] = board;  // place the table in the face numbering data field
            mesh.add( window.faceNumbers[ i ] );    
            // mesh.children[i + 1] =  window.faceNumbers[ i ];    
          }

          if ( mode === 2 || mode === 3 ) {
             for ( let i = 0; i < faceCount ; i ++ ) {
                 addBombAtFaceIndex(i);
             }

             for( let n = 0; n < window.faceNumbers.length; n ++ ) {

                  const n3 = 3 * n;

                  x = 0;
                  x += posArray[ indArray[ n3 ] * 3 ];
                  x += posArray[ indArray[ n3 + 1 ] * 3 ];
                  x += posArray[ indArray[ n3 + 2 ] * 3 ];
                  x /= 3;

                  y = 0;
                  y += posArray[ indArray[ n3 ] * 3  + 1 ];
                  y += posArray[ indArray[ n3 + 1 ] * 3 + 1 ];
                  y += posArray[ indArray[ n3 + 2 ] * 3 + 1 ];
                  y /= 3;

                  z = 0;
                  z += posArray[ indArray[ n3 ] * 3  + 2 ];
                  z += posArray[ indArray[ n3 + 1 ] * 3 + 2 ];
                  z += posArray[ indArray[ n3 + 2 ] * 3 + 2 ];
                  z /= 3;

                  const multipler = 1.03;
                  window.faceNumbers[n].position.set( x*multipler, y*multipler, z*multipler );
              }
          }

          function numbering(board, i1) {
              // i1 ++;                                                      // starts with  -1 + 1 = 0
              
              if ( i1   === 10 ) { i1   = 0; i10 ++ }
              if ( i10  === 10 ) { i10  = 0; i100 ++ }
              if ( i100 === 10 ) { i100 = 0 }                             // hundreds (reset when overflow)
              
              if ( i100 > 0 ) {
                  d100 = digit[ i100 ].clone();                           // digit for hundreds
                  board.add( d100 );                                      //  on the board ...
                  d100.position.x = -8 * 0.1 * size;                      // ... move slightly to the left
              }
              
              if ( ( i100 > 0 ) || ( ( i100 === 0 ) && ( i10 > 0 ) ) ) {  // no preceding zeros tens
                  d10 = digit[ i10 ].clone();                             // digit for tenth
                  board.add( d10 );                                       //  on the board
              }

              d1 =   digit[ i1 ].clone();                                 // digit 
              board.add( d1 );                                            //  on the board ...
              // d1.position.x = 8 * 0.1 * size;                             // ... move slightly to the right
              // d1.position.y = 8 * 0.1 * size;                             // ... move slightly to the right
          }

          this.update = function ( ) {
              if ( this.mode === 1 || this.mode === 3 ) {
                  for( let n = 0; n < vertexNumbers.length; n ++ ) {
                      vertexNumbers[n].lookAt(camera.position);
                  }
              }
              if ( this.mode === 2 || this.mode === 3 ) {
                  for( let n = 0; n < window.faceNumbers.length; n ++ ) {
                      window.faceNumbers[n].lookAt( camera.position );
                  }
              }
          }
          this.update( ); // update helper
        };

        const renderer = new THREE.WebGLRenderer({
          antialias: true
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const fov = 75;
        const aspect = window.innerWidth / window.innerHeight;
        const near = 0.01;
        const far = 50;
        const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        let bombPlacements = [];
        camera.position.z = 5;

        const caster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let revealedFaces = [];
        let flaggedFaces = [];

        const icosahedron = makeIcosahedron(new THREE.IcosahedronGeometry(3, detail), new THREE.MeshPhongMaterial({
          color: 0xadd8e6,
          shininess: 10, // Was 100
          vertexColors: true
          // specular: 0x000000,
          // flatShading: true,
        }));
        window.icosahedrons.push(icosahedron);
        icosahedron.geometry.computeVertexNormals();

        function computeAdjacentFaceIndicesMap(positionArray) {
          result = {};
          for (let i = 0; i < positionArray.length; i += 3) {
            const slice = positionArray.slice(i, i + 3);
            const key = slice[0].toString() + '|' + slice[1].toString() + '|' + slice[2].toString();
            if (result[key] !== undefined) {
              result[key].push(Math.floor(i / 9));
            } else {
              result[key] = [Math.floor(i / 9)];
            }
          }
          return result;
        }

        const adjacentFaceIndicesMap = computeAdjacentFaceIndicesMap(icosahedron.geometry.attributes.position.array);

        const wireframeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true, transparent: true, shading: THREE.FlatShading, vertexColors: true } );
        const newGeometry = new THREE.IcosahedronGeometry(3.001, detail);
        const totalFaces = newGeometry.attributes.position.count / 3;
        const bombs = Math.floor(totalFaces / 4.4);
        const wireframe = new THREE.Mesh(newGeometry, wireframeMaterial);
        indexGeometry(icosahedron.geometry);
        icosahedron.add(wireframe);

        const light = new THREE.DirectionalLight(0xffffff, 0.8);
        light.position.set(0, 0, 1);
        scene.add(light);
        const lightTop = new THREE.DirectionalLight(0xffffff, 0.8);
        lightTop.position.set(1, 3, 0.5);
        scene.add(lightTop);

        const lightBottom = new THREE.DirectionalLight(0xffffff, 1);
        // light.position.set(1, 2, 3);
        lightBottom.position.set(-1, -3, -0.5);
        scene.add(lightBottom);

        let isDragging = false;
        let mouseDown = false;
        let mouseMoves = 0;

        function getKey(x, y, z) {
          return x.toString() + '|' + y.toString() + '|' + z.toString();
        }

        function getSurroundingBombsTotal(vA, vB, vC) {
          let adjacentIndices = [];
          adjacentIndices = adjacentIndices.concat(adjacentFaceIndicesMap[getKey(vA.x, vA.y, vA.z)]);
          adjacentIndices = adjacentIndices.concat(adjacentFaceIndicesMap[getKey(vB.x, vB.y, vB.z)]);
          adjacentIndices = adjacentIndices.concat(adjacentFaceIndicesMap[getKey(vC.x, vC.y, vC.z)]);
          const uniqueAdjacentIndices = Array.from(new Set(adjacentIndices));
          return uniqueAdjacentIndices.map(ind => bombPlacements[ind]).filter(val => !!val).length;
        }

        const bombColorMap = {
          // 0: new THREE.Color(0x4A4A4A),
          0: new THREE.Color(0x8A8A8A),
          1: new THREE.Color(0xADD8E6),
          // 1: new THREE.Color(0xFFFFFF),
          2: new THREE.Color(0x00ff00),
          3: new THREE.Color(0xff0000),
          4: new THREE.Color(0xA020F0),
          5: new THREE.Color(0x964B00),
          6: new THREE.Color(0x0D98BA),
          7: new THREE.Color(0x5A5A5A),
          8: new THREE.Color(0xD3D3D3),
          9: new THREE.Color(0xFFC0CB),
          10: new THREE.Color(0x00FFFF),
          11: new THREE.Color(0xFFFF00),
          12: new THREE.Color(0xFF00FF),
        }

        function revealFace(faceIndex) {
          if (flaggedFaces.indexOf(faceIndex) !== -1) return;
          const colorAttribute = icosahedrons[0].geometry.getAttribute('color');
          const posArray = icosahedrons[0].geometry.attributes.position.array;
          var vA = new THREE.Vector3(posArray[faceIndex*9], posArray[(faceIndex*9)+1], posArray[(faceIndex*9)+2]);
          var vB = new THREE.Vector3(posArray[(faceIndex*9) + 3], posArray[(faceIndex*9)+4], posArray[(faceIndex*9)+5]);
          var vC = new THREE.Vector3(posArray[(faceIndex*9) + 6], posArray[(faceIndex*9)+7], posArray[(faceIndex*9)+8]);
          const vAkey = vA.x.toString() + '|' + vA.y.toString() + '|' + vA.z.toString();
          const vBkey = vB.x.toString() + '|' + vB.y.toString() + '|' + vB.z.toString();
          const vCkey = vC.x.toString() + '|' + vC.y.toString() + '|' + vC.z.toString();

          let isBomb = bombPlacements[faceIndex];

          // Stop the player from losing on the first click
          if (!firstClickHappened && isBomb) {
            // Put the bomb somewhere else
            const zeroIndices = [];
            for (let i = 0; i < bombPlacements.length; i++) {
              if (bombPlacements[i] === 0) {
                zeroIndices.push(i);
              }
            }

            // If there are no 0s in the array, return null
            if (zeroIndices.length === 0) {
              return null;
            }

            // Choose a random index from the list of 0 indices
            const randomIndex = Math.floor(Math.random() * zeroIndices.length);

            // Set the corresponding element in bombPlacements to 1
            bombPlacements[zeroIndices[randomIndex]] = 1;
            bombPlacements[faceIndex] = 0;
            isBomb = false;
          }

          let color = new THREE.Color(0xFFFFFF);
          if (isBomb) {
            color = new THREE.Color(0x000000); // Game over
            if (!gameOver) {
              gameOver = true;
              bombPlacements.forEach((indIsBomb, ind) => {
                if (indIsBomb) {
                  revealFace(ind);
                }
              });
              console.log('Game over');
            }
            // document.querySelector('.btn').style.display = 'block';
          } else {
            const surroundingBombs = getSurroundingBombsTotal(vA, vB, vC);
            color = bombColorMap[surroundingBombs];
            if (revealedFaces.indexOf(faceIndex) === -1) {
              vertexFaceNumberHelper(camera, icosahedron, 2, 0.1, 0x000000, faceIndex);
            }
            revealedFaces.push(faceIndex);
            if (surroundingBombs === 0) {
              let adjacentIndices = [];
              adjacentIndices = adjacentIndices.concat(adjacentFaceIndicesMap[getKey(vA.x, vA.y, vA.z)]);
              adjacentIndices = adjacentIndices.concat(adjacentFaceIndicesMap[getKey(vB.x, vB.y, vB.z)]);
              adjacentIndices = adjacentIndices.concat(adjacentFaceIndicesMap[getKey(vC.x, vC.y, vC.z)]);
              const uniqueAdjacentIndices = Array.from(new Set(adjacentIndices));
              uniqueAdjacentIndices.forEach(faceInd => {
                if (revealedFaces.indexOf(faceInd) === -1) {
                  revealFace(faceInd)
                }
              });
            }
            if (revealedFaces === totalFaces - bombs) console.log('You win!');
          }
          firstClickHappened = true;

          colorAttribute.setXYZ(faceIndex*3, color.r, color.g, color.b);
          colorAttribute.setXYZ((faceIndex*3) + 1, color.r, color.g, color.b);
          colorAttribute.setXYZ((faceIndex*3) + 2, color.r, color.g, color.b);

          colorAttribute.needsUpdate = true;
        }

        function onClick(event) {
          // event.preventDefault();
          mouseDown = false;
          if (isDragging && mouseMoves > 5) {
            isDragging = false;
            mouseMoves = 0;
            return;
          };
          mouseMoves = 0;

          mouse.x = (event.clientX / renderer.domElement.offsetWidth) * 2 - 1;
          mouse.y = -(event.clientY / renderer.domElement.offsetHeight) * 2 + 1;

          caster.setFromCamera(mouse, camera);
          if (gameOver) {
            return;
          }

          const intersects = caster.intersectObjects(scene.children).filter(intersect => intersect.face !== null);
          // window.intersects = intersects;

          if (intersects.length > 0) {

            const intersection = intersects[1];
            const faceIndex = intersection.faceIndex;
            //if (flaggedFaces.indexOf(faceIndex) !== -1) return;

            console.log(intersection);
            const colorAttribute = intersection.object.geometry.getAttribute('color');
            const face = intersection.face;
            console.log(face);
            revealFace(faceIndex);
          }
          return false;
        }

        function getBombPlacements(totalFaces, totalBombs) {
          const bombPlacements = Array(totalFaces).fill(0); // create an array of totalFaces elements, filled with 0s
          let bombsPlaced = 0;

          while (bombsPlaced < totalBombs) {
            const index = Math.floor(Math.random() * totalFaces); // generate a random index
            if (bombPlacements[index] === 0) { // if the element at the index is 0, replace it with 1
              bombPlacements[index] = 1;
              bombsPlaced++;
            }
          }
          return bombPlacements;
        }

        function makeIcosahedron(geometry, materials, x = 0, y = 0) {
          // const icosahedron = new THREE.Mesh(geometry, Array(180).fill(materials));
          const icosahedron = new THREE.Mesh(geometry, materials);

          const positionAttribute = geometry.getAttribute('position');
          const colors = [];

          for (let i = 0; i < positionAttribute.count; i++) {
            colors.push(1, 1, 1); // add for each vertex color data
          }

          const totalFaces = geometry.attributes.position.count / 3;
          const totalBombs = Math.floor(totalFaces / 4.84);
          bombPlacements = getBombPlacements(totalFaces, totalBombs);
          const colorAttribute = new THREE.Float32BufferAttribute(colors, 3);
          geometry.setAttribute('color', colorAttribute);

          icosahedron.position.x = x;
          icosahedron.position.y = y;

          scene.add(icosahedron);

          return icosahedron;
        }

        function render() {

          requestAnimationFrame(render);

          renderer.render(scene, camera);
        }

        window.onClickHandler = onClick;

        window.onRightClickHandler = (event) => {
          mouseDown = false;
          mouse.x = (event.clientX / renderer.domElement.offsetWidth) * 2 - 1;
          mouse.y = -(event.clientY / renderer.domElement.offsetHeight) * 2 + 1;

          caster.setFromCamera(mouse, camera);
          if (gameOver) {
            return false;
          }

          const intersects = caster.intersectObjects(scene.children).filter(intersect => intersect.face !== null);

          if (intersects.length > 0) {

            const intersection = intersects[1];
            if (revealedFaces.indexOf(intersection.faceIndex) !== -1) {
              return false;
            }

            const colorAttribute = intersection.object.geometry.getAttribute('color');
            const face = intersection.face;
            var vA = new THREE.Vector3();
            var vB = new THREE.Vector3();
            var vC = new THREE.Vector3();
            var geometry = intersection.object.geometry;
            var position = geometry.attributes.position;
            vA.fromBufferAttribute(position, face.a);
            vB.fromBufferAttribute(position, face.b);
            vC.fromBufferAttribute(position, face.c);

            color = new THREE.Color(0x013220);

            colorAttribute.setXYZ(face.a, color.r, color.g, color.b);
            colorAttribute.setXYZ(face.b, color.r, color.g, color.b);
            colorAttribute.setXYZ(face.c, color.r, color.g, color.b);

            colorAttribute.needsUpdate = true;
            flaggedFaces.push(intersection.faceIndex);
          }
          return false;
        }
        // window.onRightClickHandler = onRightClick;

        window.onMouseDown = (event) => {
          mouseMoves = 0;
          mouseDown = true;
        };

        let previousMousePosition = {
          x: 0,
          y: 0,
        };
        // document.addEventListener("mousemove", (event) => {
        window.onMouseMoveHandler = (event) => {
          if (mouseDown) {
            mouseMoves++;
            this.update && this.update();
            isDragging = true;
            const { x, y } = event;
            const deltaMove = {
              x: x - previousMousePosition.x,
              y: y - previousMousePosition.y,
            };

            if (mouseDown) {
              const deltaRotationQuaternion = new THREE.Quaternion().setFromEuler(
                new THREE.Euler(
                  (deltaMove.y * Math.PI) / 360,
                  (deltaMove.x * Math.PI) / 360,
                  0,
                  "XYZ"
                )
              );

              icosahedron.quaternion.multiplyQuaternions(
                deltaRotationQuaternion,
                icosahedron.quaternion
              );
            }
          }

          previousMousePosition = {
            x: event.x,
            y: event.y,
          };
        };
        render();
      }
      startGame();
    </script>
  </body>
</html>


