<!DOCTYPE html>
<html>
  <head>
    <title>3D Icosahedron</title>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script src="https://threejs.org/build/three.js"></script> 
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <script>
      // const startGame = function() {
        const BufferGeometry = THREE.BufferGeometry;
        const BufferAttribute = THREE.BufferAttribute;
        const Mesh = THREE.Mesh;
        const LineBasicMaterial = THREE.LineBasicMaterial;
        const Line = THREE.Line;

        const indexGeometry = function(geometry) {
          const indexArray = [];
          const positionArray = geometry.attributes.position.array;
          for (let i = 0; i < positionArray.length / 3; i++) {
            indexArray.push(i);
          }
          geometry.setIndex(new THREE.BufferAttribute(new Uint16Array(indexArray), 1));
        }

        const vertexFaceNumbersHelper = function ( camera, mesh, mode, size, color ) {
          // mode: 0 nothing, 1 vertex, 2 face, 3 vertex & face
          this.mode = mode;

          const positionCount = mesh.geometry.attributes.position.count;
          const faceCount = mesh.geometry.index.array.length / 3;

          const vertexNumbers = [];
          const faceNumbers = [];
          const materialDigits = new LineBasicMaterial( { color: color } );
          const geometryDigit = [];
          const digit = [];
          const digitPositions = [];
          let d100, d10, d1;      // digits

          const coordDigit = [];  // design of the digits
          coordDigit[ 0 ] = [ 0,0, 0,9, 6,9, 6,0, 0,0 ];
          coordDigit[ 1 ] = [ 0,6, 3,9, 3,0 ];
          coordDigit[ 2 ] = [ 0,9, 6,9, 6,6, 0,0, 6,0 ];
          coordDigit[ 3 ] = [ 0,9, 6,9, 6,5, 3,5, 6,5, 6,0, 0,0 ];
          coordDigit[ 4 ] = [ 0,9, 0,5, 6,5, 3,5, 3,6, 3,0 ];
          coordDigit[ 5 ] = [ 6,9, 0,9, 0,5, 6,5, 6,0, 0,0 ];
          coordDigit[ 6 ] = [ 6,9, 0,9, 0,0, 6,0, 6,5, 0,5 ];
          coordDigit[ 7 ] = [ 0,9, 6,9, 6,6, 0,0 ];
          coordDigit[ 8 ] = [ 0,0, 0,9, 6,9, 6,5, 0,5, 6,5, 6,0, 0,0 ];
          coordDigit[ 9 ] = [ 6,5, 0,5, 0,9, 6,9, 6,0, 0,0 ];

          for ( let i = 0; i < 10; i ++ ) {
              geometryDigit[ i ] = new BufferGeometry();
              digitPositions[ i ] =  new Float32Array( coordDigit[ i ].length / 2 * 3 );
              geometryDigit[ i ].setAttribute( 'position', new BufferAttribute( digitPositions[ i ], 3 ) );
              
              for ( let j = 0; j < coordDigit[ i ].length/ 2; j ++ ) {
                  digitPositions[ i ][ j * 3 ] =  0.1 * size * coordDigit[ i ][ 2 * j ];
                  digitPositions[ i ][ j * 3 + 1 ] = 0.1 * size * coordDigit[ i ][ 2 * j + 1 ];
                  digitPositions[ i ][ j * 3 + 2 ] = 0;
              }
              
              digit[ i ] = new Line( geometryDigit[ i ], materialDigits );
          }

          // ......................................................

          const posArray = mesh.geometry.attributes.position.array;
          const indArray = mesh.geometry.index.array;

          let x, y, z;

          let i100 =  0;
          let i10  =  0;
          let i1   = -1;

          window.debugBombs = {};
          window.debugCoords = {};
          function addBombAtFaceIndex(i) {
            // number on board, up to three digits are pinned there
            const board = new Mesh( new BufferGeometry( ) );
            // console.log(posArray[i*3]);
            // console.log(posArray[(i*3) + 1]);
            // const surroundingBombsKey = getKey(posArray[i*3], posArray[(i*3) + 1], posArray[(i*3) + 2]);
            var vA = new THREE.Vector3(posArray[i*9], posArray[(i*9) + 1], posArray[(i*9) + 2]);
            var vB = new THREE.Vector3(posArray[(i*9) + 3], posArray[(i*9) + 4], posArray[(i*9) + 5]);
            var vC = new THREE.Vector3(posArray[(i*9) + 6], posArray[(i*9) + 7], posArray[(i*9) + 8]);
          
            const surroundingBombs = getSurroundingBombsTotal(vA, vB, vC);
            window.debugBombs[i] = surroundingBombs;
            window.debugCoords[i] = [vA, vB, vC];
            const isBomb = bombPlacements[i];
            if (!isBomb) {
              // return;
              numbering(board, surroundingBombs); // numbering the faces, hundreds ...
            }
            // numbering(board, surroundingBombs); // numbering the faces, hundreds ...
            faceNumbers.push( board );  // place the table in the face numbering data field
            mesh.add( faceNumbers[ i ] );    
          }

          if ( mode === 2 || mode === 3 ) {
              for ( let i = 0; i < faceCount ; i ++ ) {
                  addBombAtFaceIndex(i);
                  // // number on board, up to three digits are pinned there
                  // const board = new Mesh( new BufferGeometry( ) );
                  // // console.log(posArray[i*3]);
                  // // console.log(posArray[(i*3) + 1]);
                  // // const surroundingBombsKey = getKey(posArray[i*3], posArray[(i*3) + 1], posArray[(i*3) + 2]);
                  // var vA = new THREE.Vector3(posArray[i*9], posArray[(i*9) + 1], posArray[(i*9) + 2]);
                  // var vB = new THREE.Vector3(posArray[(i*9) + 3], posArray[(i*9) + 4], posArray[(i*9) + 5]);
                  // var vC = new THREE.Vector3(posArray[(i*9) + 6], posArray[(i*9) + 7], posArray[(i*9) + 8]);
                
                  // const surroundingBombs = getSurroundingBombsTotal(vA, vB, vC);
                  // window.debugBombs[i] = surroundingBombs;
                  // window.debugCoords[i] = [vA, vB, vC];
                  // numbering(board, surroundingBombs); // numbering the faces, hundreds ...
                  // faceNumbers.push( board );  // place the table in the face numbering data field
                  // mesh.add( faceNumbers[ i ] );    
              }

             for( let n = 0; n < faceNumbers.length; n ++ ) {

                  const n3 = 3 * n;

                  x = 0;
                  x += posArray[ indArray[ n3 ] * 3 ];
                  x += posArray[ indArray[ n3 + 1 ] * 3 ];
                  x += posArray[ indArray[ n3 + 2 ] * 3 ];
                  x /= 3;

                  y = 0;
                  y += posArray[ indArray[ n3 ] * 3  + 1 ];
                  y += posArray[ indArray[ n3 + 1 ] * 3 + 1 ];
                  y += posArray[ indArray[ n3 + 2 ] * 3 + 1 ];
                  y /= 3;

                  z = 0;
                  z += posArray[ indArray[ n3 ] * 3  + 2 ];
                  z += posArray[ indArray[ n3 + 1 ] * 3 + 2 ];
                  z += posArray[ indArray[ n3 + 2 ] * 3 + 2 ];
                  z /= 3;

                  const multipler = 1.03;
                  faceNumbers[n].position.set( x*multipler, y*multipler, z*multipler );
              }
          }

          function numbering(board, i1) {
              // i1 ++;                                                      // starts with  -1 + 1 = 0
              
              if ( i1   === 10 ) { i1   = 0; i10 ++ }
              if ( i10  === 10 ) { i10  = 0; i100 ++ }
              if ( i100 === 10 ) { i100 = 0 }                             // hundreds (reset when overflow)
              
              if ( i100 > 0 ) {
                  d100 = digit[ i100 ].clone();                           // digit for hundreds
                  board.add( d100 );                                      //  on the board ...
                  d100.position.x = -8 * 0.1 * size;                      // ... move slightly to the left
              }
              
              if ( ( i100 > 0 ) || ( ( i100 === 0 ) && ( i10 > 0 ) ) ) {  // no preceding zeros tens
                  d10 = digit[ i10 ].clone();                             // digit for tenth
                  board.add( d10 );                                       //  on the board
              }

              d1 =   digit[ i1 ].clone();                                 // digit 
              board.add( d1 );                                            //  on the board ...
              // d1.position.x = 8 * 0.1 * size;                             // ... move slightly to the right
              // d1.position.y = 8 * 0.1 * size;                             // ... move slightly to the right
          }

          this.update = function ( ) {
              if ( this.mode === 1 || this.mode === 3 ) {
                  for( let n = 0; n < vertexNumbers.length; n ++ ) {
                      vertexNumbers[n].lookAt(camera.position);
                  }
              }
              if ( this.mode === 2 || this.mode === 3 ) {
                  for( let n = 0; n < faceNumbers.length; n ++ ) {
                      faceNumbers[n].lookAt( camera.position );
                  }
              }
          }
          this.update( ); // update helper
        };

        
        const renderer = new THREE.WebGLRenderer({
          antialias: true
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const fov = 75;
        const aspect = window.innerWidth / window.innerHeight;
        const near = 0.01;
        const far = 50;
        const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        let bombPlacements = [];
        camera.position.z = 5;

        const scene = new THREE.Scene();

        const caster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const detail = 3;
        let revealedTriangles = 0;

        const icosahedron = makeIcosahedron(new THREE.IcosahedronGeometry(3, detail), new THREE.MeshPhongMaterial({
          color: 0xadd8e6,
          shininess: 10, // Was 100
          vertexColors: true
          // specular: 0x000000,
          // flatShading: true,
        }));
        icosahedron.geometry.computeVertexNormals();

        function computeAdjacentFaceIndicesMap(positionArray) {
          result = {};
          for (let i = 0; i < positionArray.length; i += 3) {
            const slice = positionArray.slice(i, i + 3);
            const key = slice[0].toString() + '|' + slice[1].toString() + '|' + slice[2].toString();
            if (result[key] !== undefined) {
              result[key].push(Math.floor(i / 9));
            } else {
              result[key] = [Math.floor(i / 9)];
            }
          }
          return result;
        }

        const adjacentFaceIndicesMap = computeAdjacentFaceIndicesMap(icosahedron.geometry.attributes.position.array);

        const wireframeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true, transparent: true, shading: THREE.FlatShading, vertexColors: true } );
        const newGeometry = new THREE.IcosahedronGeometry(3.001, detail);
        const totalFaces = newGeometry.attributes.position.count / 3;
        const bombs = Math.floor(totalFaces / 4.4);
        const wireframe = new THREE.Mesh(newGeometry, wireframeMaterial);
        indexGeometry(icosahedron.geometry);
        vertexFaceNumbersHelper(camera, icosahedron, 2, 0.1, 0x000000);
        // indexGeometry(wireframe.geometry);
        // vertexFaceNumbersHelper(camera, wireframe, 2, 0.1, 0xff00ff);
        icosahedron.add(wireframe);

        const light = new THREE.DirectionalLight(0xffffff, 0.8);
        light.position.set(0, 0, 1);
        scene.add(light);
        const lightTop = new THREE.DirectionalLight(0xffffff, 0.8);
        lightTop.position.set(1, 3, 0.5);
        scene.add(lightTop);

        const lightBottom = new THREE.DirectionalLight(0xffffff, 1);
        // light.position.set(1, 2, 3);
        lightBottom.position.set(-1, -3, -0.5);
        scene.add(lightBottom);

        let isDragging = false;
        let mouseDown = false;
        let mouseMoves = 0;

        function getKey(x, y, z) {
          return x.toString() + '|' + y.toString() + '|' + z.toString();
        }

        function getSurroundingBombsTotal(vA, vB, vC) {
          let adjacentIndices = [];
          // const key1 = vA.x.toString() + '|' + vA.y.toString() + '|' + vA.z.toString()
          // const val1 = adjacentFaceIndicesMap[vA.x.toString() + '|' + vA.y.toString() + '|' + vA.z.toString()];
          // console.log(val1);
          adjacentIndices = adjacentIndices.concat(adjacentFaceIndicesMap[getKey(vA.x, vA.y, vA.z)]);
          adjacentIndices = adjacentIndices.concat(adjacentFaceIndicesMap[getKey(vB.x, vB.y, vB.z)]);
          adjacentIndices = adjacentIndices.concat(adjacentFaceIndicesMap[getKey(vC.x, vC.y, vC.z)]);
          const uniqueAdjacentIndices = Array.from(new Set(adjacentIndices));
          return uniqueAdjacentIndices.map(ind => bombPlacements[ind]).filter(val => !!val).length;
        }

        const bombColorMap = {
          0: new THREE.Color(0x5A5A5A),
          1: new THREE.Color(0xADD8E6),
          2: new THREE.Color(0x00ff00),
          3: new THREE.Color(0xff0000),
          4: new THREE.Color(0xA020F0),
          5: new THREE.Color(0x964B00),
          6: new THREE.Color(0x0D98BA),
          7: new THREE.Color(0x5A5A5A),
          8: new THREE.Color(0xD3D3D3),
          9: new THREE.Color(0xFFC0CB),
          10: new THREE.Color(0x00FFFF),
          11: new THREE.Color(0xFFFF00),
          12: new THREE.Color(0xFF00FF),
        }

        function onClick(event) {
          mouseDown = false;
          if (isDragging && mouseMoves > 5) {
            isDragging = false;
            mouseMoves = 0;
            return false;
          };
          mouseMoves = 0;
          event.preventDefault();

          mouse.x = (event.clientX / renderer.domElement.offsetWidth) * 2 - 1;
          mouse.y = -(event.clientY / renderer.domElement.offsetHeight) * 2 + 1;

          caster.setFromCamera(mouse, camera);

          const intersects = caster.intersectObjects(scene.children).filter(intersect => intersect.face !== null);
          // window.intersects = intersects;

          if (intersects.length > 0) {

            // console.log(intersects);
            const intersection = intersects[1];

            const colorAttribute = intersection.object.geometry.getAttribute('color');
            const face = intersection.face;
            // console.log(intersection);
            // console.log(face);
            var vA = new THREE.Vector3();
            var vB = new THREE.Vector3();
            var vC = new THREE.Vector3();
            var geometry = intersection.object.geometry;
            var position = geometry.attributes.position;
            vA.fromBufferAttribute(position, face.a);
            vB.fromBufferAttribute(position, face.b);
            vC.fromBufferAttribute(position, face.c);
            const vAkey = vA.x.toString() + '|' + vA.y.toString() + '|' + vA.z.toString();
            const vBkey = vB.x.toString() + '|' + vB.y.toString() + '|' + vB.z.toString();
            const vCkey = vC.x.toString() + '|' + vC.y.toString() + '|' + vC.z.toString();
            console.log(vAkey);
            console.log(vBkey);
            console.log(vCkey);

            const isBomb = bombPlacements[intersection.faceIndex];
            let color = new THREE.Color(0xFFFFFF);
            if (isBomb) {
              color = new THREE.Color(0x000000); // Game over
              console.log('Game over')
            } else {
              const surroundingBombs = getSurroundingBombsTotal(vA, vB, vC);
              console.log(surroundingBombs);
              color = bombColorMap[surroundingBombs];
              revealedTriangles++;
              if (revealedTriangles === totalFaces - bombs) console.log('You win!');
            }

            colorAttribute.setXYZ(face.a, color.r, color.g, color.b);
            colorAttribute.setXYZ(face.b, color.r, color.g, color.b);
            colorAttribute.setXYZ(face.c, color.r, color.g, color.b);

            colorAttribute.needsUpdate = true;
          }
          return false;
        }

        function getBombPlacements(totalFaces, totalBombs) {
          const bombPlacements = Array(totalFaces).fill(0); // create an array of totalFaces elements, filled with 0s
          let bombsPlaced = 0;

          while (bombsPlaced < totalBombs) {
            const index = Math.floor(Math.random() * totalFaces); // generate a random index
            if (bombPlacements[index] === 0) { // if the element at the index is 0, replace it with 1
              bombPlacements[index] = 1;
              bombsPlaced++;
            }
          }
          return bombPlacements;
        }

        function makeIcosahedron(geometry, materials, x = 0, y = 0) {
          // const icosahedron = new THREE.Mesh(geometry, Array(180).fill(materials));
          const icosahedron = new THREE.Mesh(geometry, materials);

          const positionAttribute = geometry.getAttribute('position');
          const colors = [];

          for (let i = 0; i < positionAttribute.count; i++) {
            colors.push(1, 1, 1); // add for each vertex color data
          }

          const totalFaces = geometry.attributes.position.count / 3;
          const totalBombs = Math.floor(totalFaces / 4.84);
          bombPlacements = getBombPlacements(totalFaces, totalBombs);
          const colorAttribute = new THREE.Float32BufferAttribute(colors, 3);
          geometry.setAttribute('color', colorAttribute);

          icosahedron.position.x = x;
          icosahedron.position.y = y;

          scene.add(icosahedron);

          return icosahedron;
        }

        function render() {

          requestAnimationFrame(render);

          renderer.render(scene, camera);

        }

        window.addEventListener("click", onClick, false);

        function onRightClick(event) {
          mouse.x = (event.clientX / renderer.domElement.offsetWidth) * 2 - 1;
          mouse.y = -(event.clientY / renderer.domElement.offsetHeight) * 2 + 1;

          caster.setFromCamera(mouse, camera);

          const intersects = caster.intersectObjects(scene.children);

          if (intersects.length > 0) {

            const intersection = intersects[1];

            const colorAttribute = intersection.object.geometry.getAttribute('color');
            const face = intersection.face;
            var vA = new THREE.Vector3();
            var vB = new THREE.Vector3();
            var vC = new THREE.Vector3();
            var geometry = intersection.object.geometry;
            var position = geometry.attributes.position;
            vA.fromBufferAttribute(position, face.a);
            vB.fromBufferAttribute(position, face.b);
            vC.fromBufferAttribute(position, face.c);

            color = new THREE.Color(0x013220);

            colorAttribute.setXYZ(face.a, color.r, color.g, color.b);
            colorAttribute.setXYZ(face.b, color.r, color.g, color.b);
            colorAttribute.setXYZ(face.c, color.r, color.g, color.b);

            colorAttribute.needsUpdate = true;
          }
          return false;
        }
        window.oncontextmenu = onRightClick;

        document.addEventListener("mousedown", (event) => {
          mouseMoves = 0;
          mouseDown = true;
        });

        let previousMousePosition = {
          x: 0,
          y: 0,
        };
        document.addEventListener("mousemove", (event) => {
          if (mouseDown) {
            mouseMoves++;
            this.update();
            isDragging = true;
            const { x, y } = event;
            const deltaMove = {
              x: x - previousMousePosition.x,
              y: y - previousMousePosition.y,
            };

            const deltaRotationQuaternion = new THREE.Quaternion().setFromEuler(
              new THREE.Euler(
                (deltaMove.y * Math.PI) / 360,
                (deltaMove.x * Math.PI) / 360,
                0,
                "XYZ"
              )
            );

            icosahedron.quaternion.multiplyQuaternions(
              deltaRotationQuaternion,
              icosahedron.quaternion
            );
          }

          previousMousePosition = {
            x: event.x,
            y: event.y,
          };
        });
        render();
      // }
      // startGame();
      // scene.remove(icosahedron); // This works to unrender the thing
    </script>
  </body>
</html>


